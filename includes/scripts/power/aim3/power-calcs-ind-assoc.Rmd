---
title: "Individual power calculations for lipid variant association tests"
author: "Ann Von Holle"
date: '`r format(Sys.time(), "%d %B, %Y")`'
bibliography: ../../../bib/lit-review.bib
csl: ../../../bib/vancouver.csl
output: 
  html_document:
    toc: yes
    toc_float: yes
    number_sections: true
    toc_depth: 5
    pandoc_args: [ 
      "--filter", "C:/Python27/Scripts/pandoc-eqnos.exe" 
    ]
nocite: | 
  @below_meta-analysis_2016, @elbers_gene-centric_2012, @ko_amerindian-specific_2014, @teslovich_biological_2010, @weissglas-volkov_genomic_2013, @willer_discovery_2013, @zubair_fine-mapping_2016, @tada_multiple_2014, @wu_trans-ethnic_2013, @graff_genetic_2017
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.width=12, fig.height=8,
                      echo=F, warning=FALSE,
                      message=T, 
                      results='hide',
                      comment=NA)

library(knitr)
library(plyr)

library(readxl)
library(data.table)
```


# Statistics Background


To determine which single variants to select for a linear additive model we considered conditions under which we could achieve power = 0.8 in testing the association between a variant and a continuous outcome/trait (in unrelated individuals). We assume that we pool both males and females in the analysis (n=600) and adjust for sex of child. We assume power would be lower and more conservative in the circumstances provided below absent any adjustment.

The linear model would be:

$$ Y = \beta_0 + \beta_1 X + \epsilon $$

To test the effect of $\beta_1$ under $H_0: \beta_1 = 0$ versus $H_a: \beta_1 \ne 0$, we assume the following (copied from [http://faculty.washington.edu/tathornt/SISG2014/2014_SISG_10_5.pdf](http://faculty.washington.edu/tathornt/SISG2014/2014_SISG_10_5.pdf)):

$$ T = \frac{\hat\beta_1}{\sqrt{var(\hat\beta_1)}} \sim \textbf{t}_{N-2} \approx N(0,1) \textrm{ for large N} $$

$$ T^2 = \frac{\hat\beta_1^2}{var(\hat\beta_1)} \sim \textbf{F}_{1,N-2} \approx \chi_1^2 \textrm{ for large N} $$

and

$$ var(\hat\beta_1) = \frac{\sigma_{\epsilon}^2}{S_{XX}} $$ where $S_{XX}$ is the corrected sum of squares for the $X_i's$. In this context we assume $Var(X) = 2p(1-p)$ where $p$ = MAF.

The non-centrality parameter (NCP) for this model is: 
<!-- [@sham_statistical_2014] -->

$$\lambda = N \times \frac{\beta^2 Var(X)}{\sigma_{\epsilon}^2}$$

Next, we used the NCP, $\lambda$, in a 1 df chi-square test for equality of means. We made the plots below to examine power across different levels of MAF, standard deviation of the trait and varying $\beta_1$ values all based on the SNPs listed in Appendix A of my dissertation proposal.


# MAF source

Use estimated MAF from the source studies.

```{r}
# read in maf from source studies. See create-list-snps-for-vcf.R
# at ~\GitHub\unc-dissertation-markdown-p2\includes\scripts\paper3\longleaf

setwd("~/GitHub/unc-dissertation-markdown-p2/includes/scripts/paper3/longleaf/")
load(file="vars.Rdata") # has df.allele data frame with 75 unique rsid of 79 total from Hispanic only list of variants and 208 unique rsid from 252 total European generalized. Total of 179 unique rsid from 211 total rsid on concatenation of both of those data sources.

names(df.allele) # subset this data frame to a unique combination of rsid, trait (hdl, ldl or tg)
# and use the beta and maf from sol/hchs for power calcs below.

sapply(df.allele, class)
df.allele$`Beta (SE)` = as.numeric(as.character(df.allele$`Beta (SE)`))
df.allele$power.beta = ifelse(df.allele$eur==1, df.allele$beta.sol, df.allele$`Beta (SE)`)
summary(df.allele$power.beta)

df.allele$EAF = as.numeric(as.character(df.allele$EAF))
df.allele$power.eaf = ifelse(df.allele$eur==1, df.allele$eaf.sol, df.allele$EAF)
summary(df.allele$power.eaf) # 17 missing an allele frequency... THey are from the Hispanic only samples, and these will be omitted from snp list since I don't have their eaf

# missing info
missing.eaf = df.allele[is.na(df.allele$power.eaf)==T,]$rsid
missing.eaf

table(missing.eaf %in% eur.dat.df$rsid) # 3 are in the european sample so those will be included.

```


### MAF from 1000 G AMR population for selected snps above

Exported .csv file from 1000 genomes AMR population contains minor allele frequencies for these snps.


```{r}
# 1. go to http://spsmart.cesga.es/  
# 2. then input snps from .csv file above into program to get allele freq in AMR from 1000 genomes data 2011
# 3. click on downloads tab in the final results section
# 4. then save as .csv file to following location
maf.amr = read.table("~/GitHub/unc-dissertation-markdown/includes/scripts/power/aim3/sps-download.csv", sep=";", header=T)
head(maf.amr)
dim(maf.amr) # original list of snps was 117 -- this has 107, missing 10.

```


```{r, results='markup'}
select.c = colnames(maf.amr) %in% c("SNP", "N", "MA", "MAF")

knitr::kable(maf.amr[select.c],
      row.names = F)
```

# Power calculations

SNPs from Appendix A will make up the weighted genetic risk score, and will also be the SNPs for individual variant tests.

The following information will assess which of these SNPs have enough power to detect a difference in the SLCS sample assuming:

1) n=500, 
2) effect sizes from studies listed above
3) standard deviation of the lipid outcomes from the SLCS sample.



```{r}
## List of SNPS and their effect sizes selected for each trait in Appendix A in proposal
sum(table(df.allele$Trait)) # 252
```

```{r}

names(df.allele)
maf = df.allele[is.na(df.allele$power.eaf)==F,
                c( "Trait", "Author",  "rsid", "power.beta", "power.eaf",
                  "Effect allele", "Other allele", "Chr", "eur")]
nrow(maf) # 235 left from 252 snps after omitting snps with missing eaf
all.snps = maf

# write to a file for later use -- for example, m3 table 4
setwd("~/GitHub/unc-dissertation-markdown-p2/includes/scripts/paper3")
save(all.snps, file="all-snps.Rdata") # snp.sig has the 10 snps for further analysis and sort. has the full list of snps for risk scores.

```

```{r}
# get list of snps by trait

hdl.snps = maf[maf$Trait=="HDL", "rsid"]
ldl.snps = maf[maf$Trait=="LDL", "rsid"]
tg.snps = maf[maf$Trait=="TG", "rsid"]
#tc.snps = appa.snps[appa.snps$trait=="tc", "snp2"] # no tc in buscot
```


```{r}
### HDL
hdl.snps
```

```{r}
### LDL

  ldl.snps
```

```{r}
### TG
  tg.snps
```


# Initial list of SNPs sorted by trait and Author

<!-- Notes for power calcs:

1) Keep? Below (DOI: 10.1038/srep19429): beta indicate the association between adjusted inverse normal transformed residuals of quantitative trait and genetic marker (SNP). Inverse normal transformation is the Z-scores for percentile distribution of the quantitative lipid trait (qnorm). 

Transform: Try to run intercept only regression and do inverse normal transform on residuals (qnorm). then get sd of that estimate (they are all 1)

2) KEEP: Elbers (doi:10.1371/journal.pone.0050198): additive genetic model with quantitative trait. Can keep for power analyses.

Transform: none needed.

3) partially OMIT: Ko (DOI: 10.1038/ncomms4983): binary TGs status with logistic regression using an additive genetic model, including age, sex and BMI as covariates to control for their potential confounding effects on serum TGs at the allele screen step. For the quantitative CPAS-GWAS analysis of HDLC and TC levels, HDLC and TC levels were first log-transformed to approximate normal distribution, and multiple linear regression was used.

Transform: Use the HDL and LDL Ko results by log transforming the lipid traits and getting their sd, but omit TG, which was binary.

4) (OMIT) Tada: unclear how association analyses were done so omit

**5) (KEEP) Teslovich: Numbers in ‘Effect size’ column are in mg/dl for the lead trait, Modelled as an additive effect of the minor allele.

Transform: none needed

6) (OMIT): Weissglas-Volkov (oi:10.1136/jmedgenet-2012-101461) units for 'effect size represents the odds ratio (the 95% CI) of each copy of the minor allele for the TG affection status and the proportion of 1 SD change (SE) for each copy of the minor allele for the continuous HDL-C levels' 

Can't use the result from this study for power calcs because I use an additive value.

7) Willer: Effect sizes are given with respect to the minor allele (A1) in s.d.

Transform: Get Z-scores for lipid traits, find the sd of that measure (by default 1) and use that in power calcs.

8) Wu: effect size from an additive model and corresponding to the effect allele, in the unit of mmol/L for HDL-C, LDL-C and natural log transformed TG.

Transform: Divide the lipid traits by 18 since they are given in mg/dL

9) (Keep) Zubair: we applied multiple linear
regression models and assumed an additive mode of inheritance
to test for the association between genotypes and continuous
HDL-C, LDL-C, or natural log-transformed triglyceride
levels

Transform: none needed
-->

```{r, results="markup"}
sort. = maf[order(maf$Trait, maf$Author),]
rownames(sort.) = 1:nrow(maf)
colnames(sort.) = c("Trait", "Author", "rsid",
                    "Beta", "EAF", "Effect allele", "Other allele",
                    "Chr", "generalize to Eur.")
kable(sort.)
```


```{r}
# read in lipid values from final sample (n=596)
setwd("~/")
# read in data from descriptive_statistics.Rmd
load("merged-data.Rdata") # has merge1 data frame
names(merge2)
dim(merge2)

sub.vars = c("ID",
             "LDLChlstrl", "HDLchlstrl", "trg.mg.dL.")
lvars = merge2[sub.vars]
names(lvars) = c("id", "ldl", "hdl", "tg")
summary(lvars)
lvars$log.tg = log(lvars$tg)

# do different transformations as listed above to get appropriate lipid sd for each 
# study

# 1) inverse normal transformation of residuals

transforms.f = function(x) {
  # x = lvars$ldl # debug

  # see https://www.biostars.org/p/80597/
  # and https://www.nature.com/articles/nature11401
  inv.norm.value = qnorm((rank(x,na.last="keep")-0.5)/sum(!is.na(x)))
  mean(inv.norm.value) #  = 0
  sd(inv.norm.value) # = 1
  
  log.t = log(x)
  
  z.score = scale(x, center=T, scale=T)
  
  mmol.t = x/18
  
  no.t = x
  
  return(data.frame(inv.norm = inv.norm.value,
                    log.t = log.t,
                    z.score = z.score,
                    mmol.t = mmol.t,
                    no.t = no.t))
}


# LDL
# sd for transforms: inv.norm, log.t, z.score, mmol.t, no.t
sapply(transforms.f(lvars$ldl), sd) # 1, 0.26, 1, 1.3, 23.3

# HDL
# sd for transforms: inv.norm, log.t, z.score, mmol.t, no.t
sapply(transforms.f(lvars$hdl), sd) # 1, 0.26, 1, 0.586, 10.55

# log TG
# sd for transforms: inv.norm, log.t, z.score, mmol.t, no.t
sapply(transforms.f(lvars$log.tg), sd) # 1, 0.09, 1, 0.023, 0.4187 

```

```{r}

# Look at sd for lipid traits (in mg/dl) in SLCS sample
# ---------------------------------------
phendat = read.csv(file = "~/../Dropbox/unc.grad.school/my-papers/ms-201608-1/programs/kure-analysis/phendat.csv")
dim(phendat) # 546 by 9

head(phendat)
summary(phendat)
sapply(phendat[,4:7], function(x) sd(x, na.rm=T))


# =======================================

maf = within(maf, {
  
  maf = ifelse(power.eaf>0.5, 1-power.eaf, power.eaf) 
  snp = as.character(rsid)
  
  # set sd -------------------------
  # Transform lipid traits as noted above to get appropriate sd to match the effect sizes from the studies
  # values from transforms.f function above.
  
# HDL
# sd for transforms: inv.norm, log.t, z.score, mmol.t, no.t
#sapply(transforms.f(lvars$hdl), sd) # 1, 0.26, 1, 0.586, 10.55

  sd.hdl = ifelse(Author %in% c("Below", "Below JE"), 1, # inverse normal transform
                ifelse(Author %in% c("Elbers et al"), 10.55, # no transform
                       ifelse(Author %in% c("Ko"), 0.2623186, # log(trait)
                              ifelse(Author %in% c("Tada"), NA, # not clear, omit
                                     ifelse(Author %in% c("Teslovich"), 10.554, # no transform
                                            ifelse(Author %in% c("Weissglas-Volkov", "Weissglas-Volkov D"), NA, # OR, omit
                                                   ifelse(Author %in% c("Willer"), 1, # Z-scores
                                                          ifelse(Author %in% c("Wu"), 0.586338, # mmol/L
                                                                 ifelse(Author %in% c("Zubair"), 10.554, NA))))))))) # no transform
  
# LDL
# sd for transforms: inv.norm, log.t, z.score, mmol.t, no.t
#sapply(transforms.f(lvars$ldl), sd) # 1, 0.26, 1, 1.3, 23.3

sd.ldl = ifelse(Author %in% c("Below", "Below JE"), 1, # inverse normal transform
                ifelse(Author %in% c("Elbers et al"), 23.30, # no transform
                       ifelse(Author %in% c("Ko"), 0.2553384, # log(trait)
                              ifelse(Author %in% c("Tada"), NA, # not clear, omit
                                     ifelse(Author %in% c("Teslovich"), 23.30, # no transform
                                            ifelse(Author %in% c("Weissglas-Volkov", "Weissglas-Volkov D"), NA, # OR, omit
                                                   ifelse(Author %in% c("Willer"), 1, # Z-scores
                                                          ifelse(Author %in% c("Wu"), 1.29464, # mmol/L
                                                                 ifelse(Author %in% c("Zubair"), 23.30, NA))))))))) # no transform


# log TG
# sd for transforms: inv.norm, log.t, z.score, mmol.t, no.t
#sapply(transforms.f(lvars$log.tg), sd) # 1, 0.09, 1, 0.023, 0.4187 
#sapply(transforms.f(log(lvars$tg/18)), sd) # 1, 0.28677, 1, 0.02326, 0.41874383 # log(mmol/dL) convert from mg/dL to mmol/L by divide by 18

sd.tg = ifelse(Author %in% c("Below", "Below JE"), 1, # inverse normal transform
                ifelse(Author %in% c("Elbers et al"), 0.41874383, # no transform
                       ifelse(Author %in% c("Ko"), NA, # omit
                              ifelse(Author %in% c("Tada"), NA, # not clear, omit
                                     ifelse(Author %in% c("Teslovich"), 0.41874383, # no transform
                                            ifelse(Author %in% c("Weissglas-Volkov", "Weissglas-Volkov D"), NA, # OR, omit
                                                   ifelse(Author %in% c("Willer"), 1, # Z-scores
                                                          ifelse(Author %in% c("Wu"), 0.41874383, # mmol/L (assuming standardized)
                                                                 ifelse(Author %in% c("Zubair"), 0.41874383, NA))))))))) # no transform

 # ==========================

  # set variance based on maf 
  var = 2*maf*(1-maf)
  
  # set effect size to one from app A
  # for a change in lipid (mg/dL) for a one unit change
  # in additive model

  es = as.numeric(as.character(power.beta))

  # set h2 for hdl
  h2.hdl = (es^2)*var/(sd.hdl^2)
     
  # set h2 for ldl
  h2.ldl = (es^2)*var/(sd.ldl^2)

  # set h2 for tg
  h2.tg = (es^2)*var/(sd.tg^2)
  
  # set h2 for tc
#  h2.tc = (es^2)*var/(sd.tc^2)
  
  threshold = qchisq(0.05, df=1, lower.tail=F)
  
  pwr.hdl = pchisq(threshold, df=1,lower.tail=F,
                   ncp = 500*h2.hdl)

  pwr.ldl = pchisq(threshold, df=1,lower.tail=F,
                   ncp = 500*h2.ldl)
  
  pwr.tg = pchisq(threshold, df=1,lower.tail=F,
                   ncp = 500*h2.tg)
  
#  pwr.tc = pchisq(threshold, df=1,lower.tail=F, ncp = 500*h2.tc)
})



```


```{r}
head(maf)

head(maf[maf$Author=="Wu" & maf$Trait=="TG",]) # check TG results

colnames(maf)

maf[maf$Author=="Wu",]

sub = maf[c("rsid", "Author", "Trait", 'power.beta',  'power.eaf', 'maf',
            'pwr.hdl', 'pwr.ldl', 'pwr.tg', "Effect allele", "Other allele", "Chr", "eur")]
table(sub$Author)
head(sub[sub$Author=="Wu",])

```

# SNPS with power > 0.8 to detect a main effect for relevant lipid traits in SLS sample

**NOTE**: All beta below are in mmol/L units.


## HDL-related SNPS


```{r, results='markup'}
# any power estimates exceeding 0.9 (by trait specific effect)?
kable(sub[sub$rsid %in% hdl.snps & (is.na(sub$pwr.hdl)==F & sub$pwr.hdl>0.9),
          !(colnames(sub) %in% c("pwr.ldl",'pwr.tg'))] )
```


## LDL-related SNPs
```{r, results='markup'}
kable(sub[sub$rsid %in% ldl.snps & sub$pwr.ldl>0.9 & !(is.na(sub$pwr.ldl)) & sub$Trait=="LDL",
          !(colnames(sub) %in% c("pwr.hdl",'pwr.tg'))]
      )
```

## TG-related SNPs
```{r, results='markup'}
kable(sub[sub$rsid %in% tg.snps & sub$pwr.tg>0.9 & !(is.na(sub$pwr.tg)) & sub$Trait=="TG", 
    !(colnames(sub) %in% c("pwr.ldl",'pwr.hdl'))])
```

## All sufficiently powered SNPs

```{r, results='markup'}

snp.sig = sub[ ((sub$pwr.tg>0.9 & !(is.na(sub$pwr.tg)) & sub$rsid %in% tg.snps & sub$Trait=="TG") | 
                 (sub$pwr.hdl>0.9 & !(is.na(sub$pwr.hdl)) & sub$rsid %in% hdl.snps & sub$Trait=="HDL") | 
                 (sub$pwr.ldl>0.9 & !(is.na(sub$pwr.ldl)) & sub$rsid %in% ldl.snps & sub$Trait=="LDL")) ,]

#dim(snp.sig) # 10 by 12
colnames(snp.sig) = c("rsid", "Author", "Trait",
                      "Beta", "EAF", "maf",
                      "power, HDL", "power, LDL", "power, TG",
                      "Effect allele", "Other allele", "Chr", "generalize to Eur?")
kable(snp.sig, row.names=F )

#dim(sub) # 235 by 12

# write to a file for later use -- for example, m3 table 4
setwd("~/GitHub/unc-dissertation-markdown-p2/includes/scripts/paper3")
save(snp.sig, sort., file="sig-snps.Rdata") # snp.sig has the 10 snps for further analysis and sort. has the full list of snps for risk scores.

#table(sort.$Trait)
names(sort.)

```

```{r, results='markup'}
# print off table of sign snps with identifying info
# Export info to .csv file to display in body of proposal.

#names(sub)

table.sig.snp = sub[( paste0(sub$rsid, "-", sub$Trait, "-", sub$Author) %in% paste0(snp.sig$rsid, "-", snp.sig$Trait, "-", snp.sig$Author)), 
                          c("Trait", "rsid", "Author", "Chr", "Effect allele",
                            "Other allele", "pwr.hdl", "pwr.ldl", "pwr.tg" )]
#dim(table.sig.snp) # 10 by 9
#length(unique(table.sig.snp$rsid)) # 10 unique snps

test.1 = table.sig.snp[c("rsid", "Trait")]
#nrow(unique(test.1)) # 15 unique rsid and trait combo

#kable(table.sig.snp[order(table.sig.snp$rsid),])

write.csv(table.sig.snp,
          file="~/GitHub/unc-dissertation-markdown-p2/includes/scripts/power/aim3/sig-snp.csv",
          row.names = F)

#kable(table.sig.snp)
```


```{r}

# all snps 

names(df.allele)
maf = df.allele[is.na(df.allele$power.eaf)==F,
                c( "Trait", "Author",  "rsid", "power.beta", "power.eaf",
                  "Effect allele", "Other allele", "Chr", "eur")]
nrow(maf) # 235 left from 252 snps after omitting snps with missing eaf
all.snps = maf

# write to a file for later use -- for example, m3 table 4
setwd("~/GitHub/unc-dissertation-markdown-p2/includes/scripts/paper3")
save(all.snps, file="all-snps.Rdata") # snp.sig has the 10 snps for further analysis and sort. has the full list of snps for risk scores.

# export to csv
table.snp = sub[, c("Trait", "rsid", "Author", "Chr", "Effect allele",
                        "Other allele", "pwr.hdl", "pwr.ldl", "pwr.tg" )]


write.csv(table.snp,
          file="~/GitHub/unc-dissertation-markdown-p2/includes/scripts/power/aim3/all-snp.csv",
          row.names = F)

```


# References

